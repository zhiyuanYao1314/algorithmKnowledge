# 贪心算法

## 总结：

用一句话概括就是：在通往最终答案的每一步上，贪心算法都选择当前状态下的局部最优解。

因此贪心算法只在某些条件和某些问题下保证最优解。

贪心算法的模板伪代码：

```java
1.从问题的某一初始解出发
    
while (2.朝着目标的每一步) // 2.退出条件
    do 3.选择当前最优解作为可行解的一个解 // 3. 选择局部最优解
       4.更新当前的状态 // 1. 更新当前状态
5.由所有答案组成一个最优解
```

贪心算法的主要元素：

1. 更新当前状态，如：使用硬币的数量count, 遍历到了哪个硬币
2. 退出条件，如：硬币用完了或钱已经兑换完了
3. 每一步当前的局部最优解

常见的贪心算法问题包括：最少换硬币数，最短生成树prim, 单源点最短距离dijstra等。

举例：

小明手中有 1，5，10，50，100 五种面额的纸币，每种纸币对应张数分别为 5，2，2，3，5 张。若小明需要支付 456 元，则需要多少张纸币？

1. 我们从100开始，每次选择 c = min(456/100, 5)，
2. 更新当前的state, 456 - c*100 = 
3. 判断硬币用完了或者money为0， 结束



## 总结2: 左

1. 最自然智慧的算法

2. 用一种局部最功力的标准，总是做出在当前看来最好的选择

3. 难点在于证明局部最功利的标准可以得到全局最优解

4. 对于贪心算法的学习主要以增加阅历和经验为主

   

## 经典题目目录：

1. 最少换硬币数
2. LC45 跳跃游戏2

# 1. 最少换硬币数

```java
public int min(int money){
    int[] value = new int[]{1，5，10，50，100 };
    int[] num = value int[]{5，2，2，3，5 } ;
    int i = value.length-1;
    int count =0;
    while(money != 0 && i>=0){ // 循环条件：钱每兑换完且兑换的库存没用完
        int c = Math.min(money/value[i], num[i]);
        money = money - value[i]*c;
        count += c;
    }
    if (money ==0) return count;
    return -1;
}
```



# 2. 字符串数组拼接，返回字典序最小的结果

```java
笔记x_y 和y_x大小，  


```

# 3. 会议时间

以结束时间最早最先安排；



```java
// 1. 先根据结束时间排序；
// 2. 每次从events中取区间的时候，对比左节点是否小于链表中最有一个节点的右节点，
// 3. 如果小于，舍弃，
public int maxEvents(int[][] events) {
	events;
    
}

```



# 4. 放灯

```java
// 方法1： 暴力
// 放灯


// 方法2： 贪心
// if x 不放 index++
// else
//     if x+1==len 
// 			return 
//	   else
// 	     if x+1==.
//			index +=2;
//       else index +=3;



```

# 5. 分割金条

金条的总长度是数组之和

每次都切割最大的！

`haffman 小根堆`

  ```java

// 准备一个最小堆
// 每次弹出最小的两个元素
// 加起来，放到结果集，在放回去
// 直到大小为1
...
  ```



注：堆和排序是最常用的手段！因为最有当前值得最小值/最大值



# 6. 做项目最后获得的最大钱

花费 costs[]    1   1   4    5

利润 profits[]  2   1   3   2

启动资金W 1

最多能做的项目K=2；

```java
// 贪心

// 在当前的资金里选择拥有最大利润的！
    
    
```



